<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux</title>
    <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body>
    <header>
        <div class="header-container">
            <img src="assets/img/linux.jpg" alt="Linux Icon" class="header-logo">
            <h1>Linux</h1>
            <img src="assets/img/linux.jpg" alt="Linux Icon" class="header-logo">
        </div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="python.html">Python</a></li>
                <li><a href="jinja.html">Jinja</a></li>
                <li><a href="linux.html">Linux</a></li>
            </ul>
        </nav>
    </header>

    <main>

        <!-- INDEX -->
        <section>
            <h2>Index</h2>
            <p>History, explanations and commands.</p>
            <ul>
                <li><a href="#intro">Linux</a></li>
                <li><a href="#distros">Linux Distributions</a></li>
                <li><a href="#env-vars">Environment Variables</a></li>
                <li><a href="#shell-config">Shell Configuration Files</a></li>
                <li><a href="#filesystem">Linux File System Overview</a></li>

            </ul>
        </section>



        <section id="intro">
            <h2>Linux</h2>
            <p>
                Linux began in 1991 as an independent project by Linus Torvalds, built around the idea of a free and open-source Unix-like kernel. Over time, it evolved into a complete ecosystem maintained collaboratively by thousands of developers. What started as a hobby OS became the backbone of scientific computing, servers, embedded systems and high-performance clusters. The strength of Linux comes from its modularity, its predictable behavior and the transparency of its architecture, which makes it ideal for engineering environments where control over the system matters.
            </p>

            <p>
                In Linux, interaction with the system often happens through a <em>shell</em>, which is the command interpreter that processes user instructions. Multiple shells exist, each with its own syntax and configuration model. The most widely used today is <strong>Bash</strong> (Bourne-Again Shell), standard in most modern distributions and known for its scripting capabilities and POSIX-style grammar. Some environments still rely on <strong>tcsh/csh</strong>, which have a different syntax and load configuration from separate initialization files. Knowing which shell is active is essential, because variable assignment, flow control and even basic syntax can behave differently between them.
            </p>
        </section>

        <section id="distros">
            <h2>Linux Distributions</h2>
            <p>
                Although all Linux systems share the same kernel, they are packaged into different distributions depending on their goals and design choices. <strong>Ubuntu</strong>, derived from Debian, emphasizes accessibility and rapid development cycles, making it popular for research and personal computing. <strong>Red Hat Enterprise Linux</strong> (RHEL) focuses on long-term stability and certified enterprise support. <strong>Fedora</strong> serves as a cutting-edge testing ground for new features, while <strong>Arch Linux</strong> offers a minimal, rolling-release model aimed at users who want fine-grained control over every component. Despite their differences, all distributions provide the same fundamental Linux tools and structure.
            </p>
        </section>

        <section id="env-vars">
            <h2>Environment Variables</h2>
            <p>
                Environment variables are key-value pairs stored in the shell's process environment. They define paths, tool configurations, user preferences and system behavior. Variables such as <em>PATH</em> determine where the shell looks for executable files, while others define library paths, locale settings or custom parameters for specific applications. Because variables live inside the shell environment, they only persist for the current session unless defined in a startup file. Managing environment variables is a central part of working efficiently with Linux, especially when switching between different projects or software stacks.
            </p>
        </section>

        <section id="shell-config">
            <h2>Shell Configuration Files</h2>
            <p>
                Each shell has its own initialization files that are executed when a new session starts. Bash typically reads files such as <strong>.bashrc</strong> or <strong>.bash_profile</strong>, while tcsh/csh uses <strong>.cshrc</strong>. These files define environment variables, aliases, functions and other customizations that shape the user's command-line environment. Understanding which file belongs to which shell is essential, because the configuration syntax is not interchangeable: a variable assignment valid in Bash may be invalid in tcsh. These files are the backbone of a reproducible and predictable workflow in Linux.
            </p>
        </section>

        <section id="filesystem">
            <h2>Linux File System Overview</h2>
            <p>
                The Linux file system is organized into a hierarchical structure, starting from the root directory <strong>/</strong>. Directories such as <strong>/home</strong> store user data, <strong>/etc</strong> contains system configuration files, <strong>/usr</strong> holds shared executables and libraries, and <strong>/var</strong> keeps logs and runtime data. Unlike operating systems that rely heavily on drive letters or registry systems, Linux maintains a clean, uniform directory hierarchy. Every file, device and process is exposed as part of the same tree, which makes the system both powerful and predictable from the command-line perspective.
            </p>
        </section>

        <section id="env-vars-commands">
            <h2>Setting Environment Variables</h2>
            <p>
                Environment variables define parameters that the shell and applications rely on, such as executable search paths, library locations or user-specific configuration options. They live inside the shell's environment and therefore depend on the syntax of the active shell. Although conceptually identical, Bash and tcsh use different grammar for assignment and exporting.
            </p>

            <h3>Bash</h3>
            <pre><code># temporary (current session)
export PATH="$PATH:/opt/tools/bin"
export PROJECT_ROOT="/home/ana/project"

# persistent (added to ~/.bashrc)
export LD_LIBRARY_PATH="/usr/local/lib"</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># temporary (current session)
setenv PATH "$PATH:/opt/tools/bin"
setenv PROJECT_ROOT "/home/ana/project"

# persistent (added to ~/.cshrc)
setenv LD_LIBRARY_PATH "/usr/local/lib"</code></pre>
        </section>

        <section id="sourcing-files">
            <h2>Sourcing Files</h2>
            <p>
                Sourcing a file means executing it inside the current shell session so that its variable definitions and settings remain active. This differs from running a script normally, which spawns a subshell and discards any changes when it terminates. Sourcing is essential for activating toolchains, virtual environments or project-specific setups.
            </p>

            <h3>Bash</h3>
            <pre><code># two equivalent forms
source setup.sh
. setup.sh</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># single form
source setup</code></pre>
        </section>

        <section id="aliases">
            <h2>Aliases</h2>
            <p>
                Aliases are lightweight shortcuts that replace long or repetitive commands with a custom keyword. They are resolved directly by the shell before command execution and are useful for streamlining workflows or encapsulating common command sequences. As with variables, Bash and tcsh define aliases using different syntax.
            </p>

            <h3>Bash</h3>
            <pre><code># temporary (current session)
alias ll='ls -lh'
alias py='python3'

# persistent (add to ~/.bashrc)
alias proj='cd ~/projects/main'</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># temporary (current session)
alias ll 'ls -lh'
alias py 'python3'

# persistent (add to ~/.cshrc)
alias proj 'cd ~/projects/main'</code></pre>
        </section>

    </main>
</body>
</html>


    <footer>
        <p>&copy; 2025 Ana Princival</p>
    </footer>
</body>
</html>

