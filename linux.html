<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux</title>
    <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body>
    <header>
        <div class="header-container">
            <img src="assets/img/linux.jpg" alt="Linux Icon" class="header-logo">
            <h1>Linux</h1>
            <img src="assets/img/linux.jpg" alt="Linux Icon" class="header-logo">
        </div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about_me.html">About me</a></li>
        
                <li class="dropdown">
                    <a href="#">Programming ▾</a>
                    <ul class="dropdown-content">
                        <li><a href="python.html">Python</a></li>
                        <li><a href="jinja.html">Jinja</a></li>
                        <li><a href="linux.html">Linux</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <a href="#">Neural Networks ▾</a>
                    <ul class="dropdown-content">
                        <li><a href="foundations.html">Foundations</a></li>
                        <li><a href="BNN.html">Bayesian</a></li>
                        <li><a href="classical_models.html">Classical Models</a></li>
                        <li><a href="datasets.html">Datasets</a></li>
                        <li><a href="math_tools.html">Mathematical Tools</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </header>

    <main>

        <!-- INDEX -->
        <section>
            <h2>Index</h2>
            <ul>
                <li><a href="#intro">About Linux</a></li>
                <li><a href="#distros">Linux Distributions</a></li>
                <li><a href="#env-vars">Environment Variables</a></li>
                <li><a href="#shell-config">Shell Configuration Files</a></li>
                <li><a href="#filesystem">Linux File System Overview</a></li>
                <li><a href="#env-vars-commands">Setting Environment Variables</a></li>
                <li><a href="#sourcing-files">Sourcing Files</a></li>
                <li><a href="#aliases">Aliases</a></li>
                <li><a href="#shell-startup-vs-source">Shell Startup Files vs. Manual Sourcing</a></li>
                <li><a href="#file-navigation">Navigation and File Manipulation</a></li>
                <li><a href="#permissions">Permissions</a></li>
                <li><a href="#process-management">Process Management</a></li>
                <li><a href="#networking">Basic Networking</a></li>
                <li><a href="#package-managers">Package Managers</a></li>
                <li><a href="#pipes-redirection">Pipes and Redirection</a></li>
                <li><a href="#search-filter">Search and Filtering</a></li>
                <li><a href="#compression"> Compression and Extraction</a></li>
            </ul>
        </section>

        <section id="intro">
            <h2>About Linux</h2>
            <p>
                Linux began in 1991 as an independent project by Linus Torvalds, built around the idea of a free and open-source Unix-like kernel. Over time, it evolved into a complete ecosystem maintained collaboratively by thousands of developers. What started as a hobby OS became the backbone of scientific computing, servers, embedded systems and high-performance clusters. The strength of Linux comes from its modularity, its predictable behavior and the transparency of its architecture, which makes it ideal for engineering environments where control over the system matters.
            </p>

            <p>
                In Linux, interaction with the system often happens through a <em>shell</em>, which is the command interpreter that processes user instructions. Multiple shells exist, each with its own syntax and configuration model. The most widely used today is <strong>Bash</strong> (Bourne-Again Shell), standard in most modern distributions and known for its scripting capabilities and POSIX-style grammar. Some environments still rely on <strong>tcsh/csh</strong>, which have a different syntax and load configuration from separate initialization files. Knowing which shell is active is essential, because variable assignment, flow control and even basic syntax can behave differently between them.
            </p>
        </section>

        <section id="distros">
            <h2>Linux Distributions</h2>
            <p>
                Although all Linux systems share the same kernel, they are packaged into different distributions depending on their goals and design choices. <strong>Ubuntu</strong>, derived from Debian, emphasizes accessibility and rapid development cycles, making it popular for research and personal computing. <strong>Red Hat Enterprise Linux</strong> (RHEL) focuses on long-term stability and certified enterprise support. <strong>Fedora</strong> serves as a cutting-edge testing ground for new features, while <strong>Arch Linux</strong> offers a minimal, rolling-release model aimed at users who want fine-grained control over every component. Despite their differences, all distributions provide the same fundamental Linux tools and structure.
            </p>
        </section>

        <section id="env-vars">
            <h2>Environment Variables</h2>
            <p>
                Environment variables are key-value pairs stored in the shell's process environment. They define paths, tool configurations, user preferences and system behavior. Variables such as <em>PATH</em> determine where the shell looks for executable files, while others define library paths, locale settings or custom parameters for specific applications. Because variables live inside the shell environment, they only persist for the current session unless defined in a startup file. Managing environment variables is a central part of working efficiently with Linux, especially when switching between different projects or software stacks.
            </p>
        </section>

        <section id="shell-config">
            <h2>Shell Configuration Files</h2>
            <p>
                Each shell has its own initialization files that are executed when a new session starts. Bash typically reads files such as <strong>.bashrc</strong> or <strong>.bash_profile</strong>, while tcsh/csh uses <strong>.cshrc</strong>. These files define environment variables, aliases, functions and other customizations that shape the user's command-line environment. Understanding which file belongs to which shell is essential, because the configuration syntax is not interchangeable: a variable assignment valid in Bash may be invalid in tcsh. These files are the backbone of a reproducible and predictable workflow in Linux.
            </p>
        </section>

        <section id="filesystem">
            <h2>Linux File System Overview</h2>
            <p>
                The Linux file system is organized into a hierarchical structure, starting from the root directory <strong>/</strong>. Directories such as <strong>/home</strong> store user data, <strong>/etc</strong> contains system configuration files, <strong>/usr</strong> holds shared executables and libraries, and <strong>/var</strong> keeps logs and runtime data. Unlike operating systems that rely heavily on drive letters or registry systems, Linux maintains a clean, uniform directory hierarchy. Every file, device and process is exposed as part of the same tree, which makes the system both powerful and predictable from the command-line perspective.
            </p>
        </section>

        <section id="env-vars-commands">
            <h2>Setting Environment Variables</h2>
            <p>
                Environment variables define parameters that the shell and applications rely on, such as executable search paths, library locations or user-specific configuration options. They live inside the shell's environment and therefore depend on the syntax of the active shell. Although conceptually identical, Bash and tcsh use different grammar for assignment and exporting.
            </p>

            <h3>Bash</h3>
            <pre><code># temporary (current session)
export PATH="$PATH:/opt/tools/bin"
export PROJECT_ROOT="/home/ana/project"

# persistent (added to ~/.bashrc)
export LD_LIBRARY_PATH="/usr/local/lib"</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># temporary (current session)
setenv PATH "$PATH:/opt/tools/bin"
setenv PROJECT_ROOT "/home/ana/project"

# persistent (added to ~/.cshrc)
setenv LD_LIBRARY_PATH "/usr/local/lib"</code></pre>
        </section>

        <section id="sourcing-files">
            <h2>Sourcing Files</h2>
            <p>
                Sourcing a file means executing it inside the current shell session so that its variable definitions and settings remain active. This differs from running a script normally, which spawns a subshell and discards any changes when it terminates. Sourcing is essential for activating toolchains, virtual environments or project-specific setups.
            </p>

            <h3>Bash</h3>
            <pre><code># two equivalent forms
source setup.sh
. setup.sh</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># single form
source setup</code></pre>
        </section>

        <section id="aliases">
            <h2>Aliases</h2>
            <p>
                Aliases are lightweight shortcuts that replace long or repetitive commands with a custom keyword. They are resolved directly by the shell before command execution and are useful for streamlining workflows or encapsulating common command sequences. As with variables, Bash and tcsh define aliases using different syntax.
            </p>

            <h3>Bash</h3>
            <pre><code># temporary (current session)
alias ll='ls -lh'
alias py='python3'

# persistent (add to ~/.bashrc)
alias proj='cd ~/projects/main'</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># temporary (current session)
alias ll 'ls -lh'
alias py 'python3'

# persistent (add to ~/.cshrc)
alias proj 'cd ~/projects/main'</code></pre>
        </section>

        <section id="shell-startup-vs-source">
            <h2>Shell Startup Files vs. Manual Sourcing</h2>
            <p>
                Shells load part of their configuration automatically when a new terminal session begins. These files are known as startup files and their names depend on the shell: Bash reads <strong>.bashrc</strong> or <strong>.bash_profile</strong>, while tcsh/csh reads <strong>.cshrc</strong>. Because these files are executed by the shell itself at startup, any variables, aliases or functions defined there become available immediately, without further action from the user. They establish the default environment for every session.
            </p>

            <p>
                In contrast, sourcing a file is a deliberate, manual action. When a file is sourced, its contents are executed inside the current shell, extending or overriding the environment dynamically. This is typically used for project-specific configurations, tools that require custom paths, or environments that should not load globally. While startup files define the baseline behavior of the shell, sourced files activate additional layers of configuration only when explicitly requested. Understanding this distinction is essential for keeping environments clean, reproducible and predictable.
            </p>
        </section>

        <section id="file-navigation">
            <h2>Navigation and File Manipulation</h2>
            <p>
                Navigating the filesystem is a fundamental part of working in Linux. Directories and files are manipulated through simple commands that behave consistently across distributions. Although Bash and tcsh share the same underlying commands, shell syntax may differ in how paths or variables are expanded. Understanding how to move through directories, list contents and manipulate files provides the foundation for more advanced command-line usage.
            </p>

            <h3>Bash</h3>
            <pre><code># navigate directories
cd /home/ana
cd ..

# list files
ls
ls -lh

# copy, move, remove
cp source.txt backup.txt
mv file.txt newname.txt
rm oldfile.txt

# create directories
mkdir newfolder</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># navigate directories
cd /home/ana
cd ..

# list files
ls
ls -lh

# copy, move, remove
cp source.txt backup.txt
mv file.txt newname.txt
rm oldfile.txt

# create directories
mkdir newfolder</code></pre>
        </section>

        <section id="permissions">
            <h2>File Permissions</h2>
            <p>
                Linux enforces a permission model that defines which users can read, write or execute a file. Permissions apply to three categories: the file owner, members of the owner's group and all other users. Managing permissions is crucial not only for security but also for workflows involving scripts, tools or shared directories. The commands themselves are identical across Bash and tcsh, since they operate at the system level rather than within the shell language.
            </p>

            <h3>Bash</h3>
            <pre><code># view permissions
ls -l

# change permissions
chmod 755 script.sh
chmod u+rwx file.txt

# change owner (requires privileges)
sudo chown ana file.txt</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># view permissions
ls -l

# change permissions
chmod 755 script.sh
chmod u+rwx file.txt

# change owner (requires privileges)
sudo chown ana file.txt</code></pre>
        </section>

        <section id="process-management">
            <h2>Process Management</h2>
            <p>
                Processes represent running programs in the system, each identified by a process ID (PID). Managing processes involves inspecting what is running, terminating tasks and monitoring resource usage. These operations rely on core Unix tools that behave identically regardless of the shell being used. The shell only affects how variables or substitutions are written, not how process commands operate.
            </p>

            <h3>Bash</h3>
            <pre><code># list processes
ps aux
top

# terminate a process by PID
kill 12345

# terminate forcefully
kill -9 12345</code></pre>

            <h3>tcsh/csh</h3>
            <pre><code># list processes
ps aux
top

# terminate a process by PID
kill 12345

# terminate forcefully
kill -9 12345</code></pre>
        </section>

        <section id="networking">
            <h2>Basic Networking</h2>
            <p>
                Linux provides a set of command-line tools for remote access, file transfer and connectivity testing. These utilities behave consistently across shells, since they operate at the system level. Mastering them is fundamental for interacting with remote servers, transferring data securely and diagnosing network issues.
            </p>

            <h3>Commands (Bash and tcsh/csh)</h3>
            <pre><code># check connectivity
ping google.com

# connect to a remote machine
ssh user@hostname

# copy files securely (local → remote)
scp file.txt user@hostname:/path/

# copy files securely (remote → local)
scp user@hostname:/path/file.txt .
</code></pre>
        </section>

        <section id="package-managers">
            <h2>Package Managers</h2>
            <p>
                Linux distributions include package managers responsible for installing, updating and removing software. Each distribution family uses a different tool: Debian-based systems use <strong>apt</strong>, Red Hat-based systems use <strong>dnf</strong>, and Arch-based systems rely on <strong>pacman</strong>. Although their syntax differs, they all provide a structured way to maintain system software and dependencies.
            </p>

            <pre><code># Debian/Ubuntu (apt)
sudo apt update
sudo apt install vim
sudo apt remove package

# Fedora/Red Hat (dnf)
sudo dnf install vim
sudo dnf remove package

# Arch Linux (pacman)
sudo pacman -Syu
sudo pacman -S vim
sudo pacman -R package
</code></pre>
        </section>

        <section id="pipes-redirection">
            <h2>Pipes and Redirection</h2>
            <p>
                Pipes connect the output of one command to the input of another, enabling command chaining and data transformation. Redirection, by contrast, routes output to files or reads input from files. These mechanisms are central to the Unix philosophy of composing small tools into more complex operations. Their syntax is identical in Bash and tcsh, since they are interpreted directly by the shell parser.
            </p>

            <h3>Bash and tcsh/csh</h3>
            <pre><code># pipe output of one command into another
ls -l | grep ".txt"

# redirect output to a file (overwrite)
echo "Hello" > file.txt

# redirect output to a file (append)
echo "More text" >> file.txt

# redirect input from a file
wc -l < file.txt
</code></pre>
        </section>

        <section id="search-filter">
            <h2>Search and Filtering</h2>
            <p>
                Linux provides powerful tools for searching and filtering data. <strong>grep</strong> scans text for patterns, while <strong>find</strong> searches the filesystem based on name, type or other attributes. These tools enable fast inspection of directories, logs and large datasets. Their behavior is the same across shells, with no syntax differences.
            </p>

            <h3>Bash and tcsh/csh</h3>
            <pre><code># search for a pattern in a file
grep "error" logfile.txt

# recursive search
grep -R "TODO" .

# find files by name
find . -name "*.txt"

# find directories only
find /path -type d
</code></pre>
        </section>

        <section id="compression">
            <h2>Compression and Extraction</h2>
            <p>
                Linux supports multiple compression formats, with <strong>tar</strong> being the most common for packaging directories and <strong>gzip</strong> or <strong>zip</strong> providing lightweight compression. These tools are essential for archiving, transferring and storing data efficiently. Their syntax is identical across shells.
            </p>

            <h3>Bash and tcsh/csh</h3>
            <pre><code># create a compressed tar archive
tar -czvf archive.tar.gz folder/

# extract a tar archive
tar -xzvf archive.tar.gz

# gzip a single file
gzip data.txt

# unzip a .gz file
gunzip data.txt.gz

# zip and unzip
zip archive.zip file1 file2
unzip archive.zip
</code></pre>
        </section>

    </main>
</body>
</html>


    <footer>
        <p>&copy; 2025 Ana Princival</p>
    </footer>
</body>
</html>

